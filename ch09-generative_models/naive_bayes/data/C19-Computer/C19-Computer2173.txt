计算机应用研究
APPLICATION RESEARCH OF COMPUTERS
2000　Vol.17　No.2　P.4-5



面向对象的通信软件设计工具ObjecTime
胡亮　程文青
摘 要 以一种新型的面向对象的通信软件开发工具ObjecTime为对象，介绍了通信软件设计中的面向对象的概念以及ObjecTime的开发环境和开发过程。
关键词 ObjecTime 面向对象 通信软件
　　随着通信事业的发展，通信软件的更新与升级速度越来越快，许多的通信软件有待开发。运用传统的方法开发实时的通信软件往往需要上百个人年，而设计的软件既不利于维护，也不利于复用和升级。通信软件的开发迫切地需要一种新的方法和新的工具。自面向对象的程序设计出现后，整个软件设计业都发生了深刻的变化。本文介绍的ObjecTime就是基于实时面向对象方法(ROOM：Real-time Object-oriented Modeling)的通信软件CASE工具。
1 ObjecTime中的面向对象的概念
1.1 对象
　　在面向对象的系统中,对象是基本的运行的实体,它既包括数据(属性),也包括作用与数据的操作(行为)。在ObjecTime中，有三种不同的对象，一是执行者(Actor)，通信系统中的任何实体都可以抽象为执行者。执行者有它的结构和行为。结构可以层层嵌套，从而形成一个十分复杂的系统。在通信软件中，用来表示行为的最常用的形式是有限状态自动机。ObjecTime运用图形化、层次化的由HAREL状态图演化过来的有限状态自动机来支持面向对象的概念，并使实时软件的开发更加方便、更加有效。第二种对象是协议类对象，它用来描述执行者的端口可以发送和接收的消息类型。三是数据类，它和其它面向对象的语言中的数据类一样，有数据格式定义和对于数据的操作。数据类既可以是ObjecTime中已有的类型，也可以是重新定义的类型，在必要时，还可以引入在C++开发环境中定义的外部数据类型。
1.2 消息
　　执行者之间进行通信的一种构造叫做消息。当一个消息发送给某个执行者时，包含要求接收执行者去执行某些活动的消息。接收到消息的执行者经过解释，然后予以响应。这种通信机制叫做消息传递。发送消息的执行者不需要知道接收消息的执行者如何对请求予以响应。消息中包含有数据和消息的优先级。数据是数据类的实例。
1.3 继承性
　　继承性是父类和子类之间共享数据和方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。在ObjecTime中，三种对象定义的类都可以通过继承达到复用。
　　继承性是面向对象程序设计语言不同于其它语言的最主要的特点，是其它语言(如面向过程的语言)所没有的。
1.4 多态
　　在收到消息时，执行者要予以响应。不同的执行者收到同一消息可产生完全不同的结果，这一现象叫做多态。在使用多态的时候，用户可以发送一个通用的消息，而实现细节则由接收执行者自行决定，这样，同一消息就可以调用不同的方法。
　　多态的实现受到继承性的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，不同的实现这一功能的行为放在较低层次，在较低层次上生成的对象能够给通用消息以不同的响应。
1.5 动态联编
　　联编是把一个过程调用和响应调用而需要执行的码加以结合的过程，在一般的程序设计语言中，联编是在编译时候进行的，叫做静态联编。动态联编则是在运行时进行的，因此，一个给定的过程调用和码的结合，直到调用发生时才进行编译的。由于动态联编是在编译以后才进行的，所以也叫“滞后联编”。
2 ObjecTime 的开发环境
　　如图1所示，ObjecTime将从设计分析、编辑代码到编译连接及仿真的所有工具都集成在了ObjecTime工具集中。

图1
2.1 模型管理
　　多用户的开发环境支持一个ObjecTime开发小组的合作开发。所有的执行者类、协议类和数据类都可以存储于类库中或者是作为个人文件存储于文件中。 类库提供了一种保存类的正式方法，它可以保证类的正确性和合法地取用和修改，保证不同开发者所使用的类具有一致性。
2.2 模型编辑
　　ObjecTime提供了许多各种编辑模型的编辑器，包括图形化的和非图形化的。编辑文档的工具可以把文档和它直接说明的对象联系在一起。所有的图形化的和非图形化的文档都可以转换成标准文档格式，如Word文档。
2.3 交叉引用管理
　　ObjecTime提供了交叉引用的管理。无论是代码还是图形化的模型，都可以通过这个工具找到引用过它的实体。
2.4 模型编译
　　ObjecTime提供了模型编译工具，它可以把在ObjecTime中创建的ROOM模型转换为高级语言的原代码，然后调用高级语言的编译器把它转换为可执行的程序。本文的系统平台是WindowsNT，使用的高级语言的编译器是Visual C++ 5.0的编译器。
2.5 模型检验
　　ObjecTime提供了模型检验工具。它可以检验出不正确的执行者类，如执行者的发送端口发送的消息和对方接收的消息类型不匹配等错误，使开发者能及时发现错误加以修改。ObjecTime还提供了一个强大的仿真环境，通过仿真，可以使开发者进一步检验软件的功能是否合符要求，同时也可以使开发者对软件在目标平台的运行情况有一定的了解。
3 一个简单系统的建模过程
　　为了介绍开发过程，我们以大家所熟悉的电话系统为例，构造一个十分简单的系统。作为一个电话系统，首先要建立一个电话机的模型。在ObjecTime中它就是一个执行者。它的结构很简单，它的内部不包含任何其它的执行者。它只有一个端口，它是电话线接口的模型。但是，电话机的行为很复杂，如图2所示，我们运用了层次化的状态机来描述电话机的行为。图中的圆角矩形代表状态，箭头线代表状态转换。建立好电话机的模型后，可以通过继承，在电话机的初始化的过程中加入一些呼叫的代码，形成用于作为主叫的电话机。在一个作为系统的执行者中加入两个电话机，其中一个是主叫子类的实例，并把他们的端口连接起来形成一个消息通道。这样一个简单的系统就可以在ObjecTime环境中编译并在仿真环境中运行了。仿真环境运用图形化的监测窗口，它们可以十分逼真地动态地显示模型的运行结果。这些窗口主要包括消息窗口，行为窗口，结构窗口，变量窗口。运用这些窗口，可以同时进行白盒测试和黑盒测试。如，只打开消息窗口，即可知道当一个消息输入时执行者发出什么样的消息。这时，我们把整个执行者连同它的结构和行为都作为黑盒子看待；如果我们打开结构窗口和行为窗口，我们可以看到结构的动态变化和有限状态自动机的状态转换。这时，执行者对我们而言是一个透明的实体。在进一步地完善过程，还可以加入交换机的模型。实际上，在ObjecTime中可以开发十分复杂的通信软件。由于ObjecTime有强大的图形化的开发和仿真环境，运用它来开发通信软件，可以大大节省人力，它的出现是通信软件设计的一个里程碑。

图2
胡亮（华中理工大学电信系 武汉 430074）
程文青（华中理工大学电信系 武汉 430074）
参考文献
1，Tutorial Guide. ObjecTime Limited
2，Tolset Guide. ObjecTime Limited
3，C++ Guide. ObjecTime Limited
4，蔡希尧, 陈 平. 面向对象技术. 西安：西安电子科技大学出版社
收稿日期：1999年7月16日
